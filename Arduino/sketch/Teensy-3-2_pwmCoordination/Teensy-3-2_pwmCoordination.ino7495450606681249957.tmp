#include "t3pwm.h" // chip-specific implementations
#include "t3adc.h"

T3PWM* thePWM;
T3ADC* theADC;

// Sin table normalized to amplitude of 600, 180 deg zero values, 2 degree angle resolution (to re-write when doing proper svpwm code)
const uint16_t sintable[] = {
  0, 21, 42, 63, 84, 104, 125, 145, 165, 185, 205, 225, 244, 263, 282, 300, 318, 336, 353, 369, 386, 401, 417, 432, 446, 460, 473, 485, 497, 509, 520,
  530, 539, 548, 556, 564, 571, 577, 582, 587, 591, 594, 597, 599, 600, 600, 600, 599, 597, 594, 591, 587, 582, 577, 571, 564, 556, 548, 539, 530, 520,
  509, 497, 485, 473, 460, 446, 432, 417, 401, 386, 369, 353, 336, 318, 300, 282, 263, 244, 225, 205, 185, 165, 145, 125, 104, 84, 63, 42, 21, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

// Phasenlage von u,v,w
byte u = 0;       // Phase U ->   0 Grad Referenz
byte v = 180 - 60; // Phase V -> 120 Grad sp채ter
byte w = 180 - 120; // Phase W -> 240 Grad sp채ter
byte Ramp = 1; // Spannungsabsenkung bei kleinen Drehzahlen


IntervalTimer timer_Sin;    // 1 Sekunden Timer

void setup () {

  Serial.begin(115200);

  pinMode(13, OUTPUT);
  pinMode(14, OUTPUT);

  thePWM = new T3PWM();
  theADC = new T3ADC(PIN_SENSA_A, PIN_SENSA_B, PIN_SENSA_C, PIN_SENSV_A, PIN_SENSV_B, PIN_SENSV_C);
  // initialize the digital pin as an output.


  thePWM->init();
  theADC->init();

  timer_Sin.begin(TimerSin, 130); //   Timer
}

void loop ()
{
  delay(1);
}

void TimerSin()
{
  thePWM->setPhases(sintable[u] / Ramp, sintable[v] / Ramp, sintable[w] / Ramp); // PWM-Tastverh채ltnis f체r Phase u setzen, Aplitude skalieren

  u++;
  if (u == 180) u = 0;
  v++;
  if (v == 180) v = 0;
  w++;
  if (w == 180) w = 0;

  //led = ~led;
  //digitalWrite(Trigger_01, led);
}

const uint8_t tickPin = 14;
const bool on = HIGH;
const bool off = LOW;
/*
void adc0_isr(void){
  if(ADC0_SC1A & ADC_SC1_COCO){ // status regitser & conversion & complete flag
    result0RA = (unsigned short)ADC0_RA; // adc result data register
      led = ~led;
      digitalWrite(tickPin, led);
  }
  led = ~led;
  digitalWrite(tickPin, led);
}
*/
void adc1_isr(void){ // not an object f'n bc triggered in some depths of teensy core that I don't understand
  digitalWriteFast(tickPin, on);
  if(ADC1_SC1A & ADC_SC1_COCO){ // status regitser & conversion & complete flag
    theADC->RB_SENSA_B.push((uint16_t)ADC1_RA); // adc result data register
  }
  digitalWriteFast(tickPin, off);
}

